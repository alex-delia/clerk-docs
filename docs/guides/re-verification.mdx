---
title: Get started with Re-verification
description: Learn how to leverage Clerk's re-verification feature to protect sensitive actions within your application.
---

## Introduction

After a user signs into your application, you may want to control their access and actions based on how long they have been logged in.

For example, in a banking application, transferring money between accounts is considered a ‚Äúsensitive action.‚Äù In such cases, you may require the user to ‚Äúre-verify‚Äù their credentials before completing the action.

Clerk provides a suite of utilities to help you implement a seamless re-verification flow.

- `auth().has()` now accepts a `reverification` attribute
- `useReverification()` automatically displays a modal prompting the end-user to reverify their credentials and resume the sensitive action.

> [!NOTE]
> This feature is currently on Public Beta.

## Mutations on sensitive resources

To reduce the risk of unauthorized access to a user‚Äôs account during sensitive actions, you can periodically require users to reverify their active session by confirming their credentials

<Tabs type="framework" items={["Next.js Server Action", "Next.js Route Handler", "Ruby w/ React", "Other"]}>
  <Tab>
    ### Authorizing your server actions

    ```ts {{ filename: '/app/actions.ts' }}
    'use server'

    import { auth, reverificationError } from '@clerk/nextjs/server'

    export const myAction = async () => {
      const { orgId, has } = await auth.protect()

      const shouldUserRevalidate = !has({ reverification: 'strict' })

      if (shouldUserRevalidate) {
        return reverificationError('strict')
      }

      return { success: true }
    }
    ```

    ### Handling authorization errors on the client

    Once our actions are authorized, we need to handle the authorization error that might reach the client. For that, we have introduced a new hook called `useReverification` that will detect the authorization error and automatically display a UI in a modal that enables the end-user to verify their identity. On success the previously failed request will be retried automatically.

    ```tsx {{ filename: '/app/perform-action/page.tsx' }}
    'use client'

    import { useReverification } from '@clerk/nextjs'
    import { myAction } from '@/app/actions'

    export function MyButton() {
      const [performAction] = useReverification(myAction)

      return (
        <button
          onClick={async () => {
            const myData = await performAction()
            if (!myData) return
            console.log(myData)
          }}
        >
          Perform Action
        </button>
      )
    }
    ```
  </Tab>

  <Tab>
    ### Authorizing your route handlers

    ```ts {{ filename: '/app/api/transfer-balance/route.ts' }}
    import { auth, reverificationErrorResponse } from '@clerk/nextjs/server'

    export const POST = async (req: Request) => {
      const { has } = await auth.protect()

      const shouldUserRevalidate = !has({ reverification: 'strict' })

      if (shouldUserRevalidate) {
        return reverificationErrorResponse('strict')
      }

      return new Response(JSON.stringify({ success: true }))
    }
    ```

    ### Handling authorization errors on the client

    Once our endpoints are authorized, we need to handle the authorization error that might reach the client. For that, we have introduced a new hook called `useReverification` that will detect the authorization error and automatically display a UI in a modal that enables the end-user to verify their identity. On success the previously failed request will be retried automatically.

    ```tsx {{ filename: '/app/transfer/page.tsx' }}
    'use client'

    import { useReverification } from '@clerk/nextjs'

    export function TransferButton({ amount_in_cents }) {
      const [transferMoney] = useReverification(() =>
        fetch('/api/transfer-balance', {
          method: 'POST',
          body: JSON.stringify({ amount_in_cents }),
        }),
      )

      return <button onClick={transferMoney}>Transfer</button>
    }
    ```
  </Tab>

  <Tab>
    In your controller add a filter that leverages the new helpers

    ```ruby
    # app/controllers/home_controller.rb
    class HomeController < ApplicationController
      before_action :require_reverification, only: :foo

      def foo
        render json: { sucess: "true" }
      end

      private
      
      # will halt the request and respond with a JSON that Clerk.js
      # will read and kickstart a re-verification flow 
      def require_reverification
        clerk_render_reverification if clerk_user_needs_reverification?
      end
    end
    ```

    ### Handling authorization errors on the client

    In your react application you can simply wrap your fetcher with `useReverification()`.

    ```tsx
    import { useReverification } from '@clerk/react'

    export function TransferButton({ amount_in_cents }) {
      const [transferMoney] = useReverification(() =>
        fetch('/api/transfer-balance', {
          method: 'POST',
          body: JSON.stringify({ amount_in_cents }),
        }),
      )

      return <button onClick={transferMoney}>Transfer</button>
    }
    ```
  </Tab>

  <Tab>
    You can use the `reverificationMismatchResponse` exported from `@clerk/shared/authorization-errors` . If you are not using Javascript / Typescript, you can create your own helper that returns this JSON response:

    ```json
    {
      "clerk_error": {
        "type": "forbidden",
        "reason": "reverification-mismatch"
      }
    }
    ```

    It is also advised to use a 403 status code on your response.
  </Tab>
</Tabs>

## Caveats

Before opting-in to this feature, there are a few important considerations:

1. **Available Factors for Reverification**: Not all authentication factors can be used for reverification.

The available options are:

- First factors: Password, Email code, Phone code
- Second Factors: Phone code, Authenticator app, Backup code

1. **Eligibility for Sensitive Actions**: If a user does not have any of the above factors configured, they will be unable to reverify their credentials and therefore ineligible to perform ‚Äúsensitive actions.‚Äù
1. **Graceful Downgrade of Verification Level**: If you request a `second_factor` or `multi_factor` level of verification but the user does not have the required factor available, our utilities automatically downgrade the requested level to `first_factor` to ensure a smoother experience.

## Wrap up

Your onboarding flow is now complete! üéâ Users who have not onboarded yet will now land on your `/onboarding` page. New users signing up or signing in to your application will have to complete the onboarding process before they can access your application. By using Clerk, you have streamlined the user authentication and onboarding process, ensuring a smooth and efficient experience for your new users.
