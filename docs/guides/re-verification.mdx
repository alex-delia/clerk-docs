---
title: Get started with Re-verification
description: Leverage Clerk‚Äôs utilities, to frequently ask users to verify their identity before sensitive actions are performed.
---


## Introduction

After a user has signed-in into your application, you may want to limit what they can access and control what actions they are allowed to perform based on how long the are logged in for.

For example, in a banking application, transferring money from one account to another is considered a ‚Äúsensitive action‚Äù and the end-user should be prompted to ‚Äúre-verify‚Äù their credentials before that sensitive action is completed.

Clerk offers a suite of utilities that helps you handle a re-verification flow.

- `auth().has()` now accepts a `reverification` attribute
- `useReverification()` is introduced to automatically prompt the end-user with a modal to reverify their credential and resume the sensitive action.

> [!NOTE]
> This feature is currently on Public Beta.

## Mutations on sensitive resources
In order to decrease the chances of a user‚Äôs account being accessible to unauthorized actors performing sensitive actions, you can frequently ask for the user to re-verify their active session, by verifying their credentials on the spot.

<Tabs type="framework" items={["Next.js Server Action", "Next.js Route Handler", "Ruby w/ React", "Other"]}>
  
  <Tab>
    
    ### Authorizing your server actions
    
    ```ts {{ filename: '/app/actions.ts' }}
    "use server";

    import { auth, reverificationError } from "@clerk/nextjs/server";

    export const myAction = async () => {
      const { orgId, has } = await auth.protect();
      
      const shouldUserRevalidate = !has({ reverification: "strict"})
      
      if (shouldUserRevalidate) {
        return reverificationError("strict");
      }

      return { success: true };
    };
    ```
    ### Handling authorization errors on the client
    Once our actions are authorized, we need to handle the authorization error that might reach the client. For that, we have introduced a new hook called `useReverification` that will detect the authorization error and automatically display a UI in a modal that enables the end-user to verify their identity. On success the previously failed request will be retried automatically.

    ```tsx {{ filename: '/app/perform-action/page.tsx' }}
    "use client";

    import { useReverification } from "@clerk/nextjs";
    import { myAction } from '@/app/actions'

    export function MyButton() {
      const [performAction] = useReverification(myAction);

      return (
        <button
          onClick={async () => {
            const myData = await performAction()
            if(!myData) return 
            console.log(myData)
          }}
        >
          Perform Action
        </button>
      );
    }
    ```
  </Tab>
  <Tab>
    ### Authorizing your route handlers

    ```ts {{ filename: '/app/api/transfer-balance/route.ts' }}
    import { auth, reverificationErrorResponse } from "@clerk/nextjs/server";

    export const POST = async (req: Request) => {
      const { has } = await auth.protect();
      
      const shouldUserRevalidate = !has({ reverification: "strict"})
      
      if (shouldUserRevalidate) {
        return reverificationErrorResponse("strict");
      }

      return new Response(JSON.stringify({ success: true }))
    };
    ```

    ### Handling authorization errors on the client
    Once our endpoints are authorized, we need to handle the authorization error that might reach the client. For that, we have introduced a new hook called `useReverification` that will detect the authorization error and automatically display a UI in a modal that enables the end-user to verify their identity. On success the previously failed request will be retried automatically.

    ```tsx {{ filename: '/app/transfer/page.tsx' }}
    "use client";

    import { useReverification } from "@clerk/nextjs";

    export function TransferButton({ amount_in_cents }) {
      const [transferMoney] = useReverification(()=>
        fetch("/api/transfer-balance", {
          method: "POST",
          body: JSON.stringify({ amount_in_cents })
        }))

      return (
        <button onClick={transferMoney}>
          Transfer
        </button>
      );
    }
    ```
  </Tab>
  <Tab>
    In your controller add a filter that leverages the new helpers
    ```ruby
    # app/controllers/home_controller.rb
    class HomeController < ApplicationController
      before_action :require_reverification, only: :foo

      def foo
        render json: { sucess: "true" }
      end

      private
      
      # will halt the request and respond with a JSON that Clerk.js
      # will read and kickstart a re-verification flow 
      def require_reverification
        clerk_render_reverification if clerk_user_needs_reverification?
      end
    end
    ```
    ### Handling authorization errors on the client
    In your react application you can simply wrap your fetcher with `useReverification()`.
    ```tsx
    import { useReverification } from "@clerk/react";

    export function TransferButton({ amount_in_cents }) {
      const [transferMoney] = useReverification(()=>
        fetch("/api/transfer-balance", {
          method: "POST",
          body: JSON.stringify({ amount_in_cents })
        }))

      return (
        <button onClick={transferMoney}>
          Transfer
        </button>
      );
    }
    ```
  </Tab>
  <Tab>
  You can use the `reverificationMismatchResponse` exported from `@clerk/shared/authorization-errors` . If you are not using Javascript / Typescript, you can create your own helper that returns this JSON response:
  ```json
  {
    "clerk_error": {
      "type": "forbidden",
      "reason": "reverification-mismatch",
    }
  }
  ```
  It is also advised to use a 403 status code on your response.
  </Tab>
</Tabs>


## Caveats
There are a few things to consider, before you opt-in to this feature.
1. Not all factors are available to be used for re-verification. The available are:
  - First factors: Password, Email code, Phone code
  - Second Factors: Phone code, Authenticator app, Backup code
2. If a user does not have any of the above, they will not be able to re-verify their credentials and thus not be eligible to perform ‚Äúsensitive actions‚Äù.
3. When you are requesting for a level of `second_factor` or `multi_factor` but the end-user does not have one available, our utilities gracefully downgrade the requested level to `first_factor`.


## Wrap up

Your onboarding flow is now complete! üéâ Users who have not onboarded yet will now land on your `/onboarding` page. New users signing up or signing in to your application will have to complete the onboarding process before they can access your application. By using Clerk, you have streamlined the user authentication and onboarding process, ensuring a smooth and efficient experience for your new users.
